# hanghae99_1st_week
항해99 1주차 과제

Q.
protected 는 어떤 상황에서 쓰는가? 이 역시 private 와 마찬가지로 test 가 어려울것 같은데 실무에서는 어떤형식으로 사용하는지 궁금하다.


# 동시성 제어 방식 및 각 적용의 장/단점

## 동시성이란 (Concurrency)
- 한 시스템에서 여러 작업(task) 들이 겹쳐서 동시에 실행되는 것처럼 보이는 상황 또는 특성
- 여러가지 작업이 짧은 시간 동안 빠르게 작업을 switch 하면서 수행하는 것을 의미
- 동시에 실행되는 것 처럼 보이는 것

## 병렬성이란 (Parallelism)
- 물리적으로 여러 자원을 이용해 실제로 동시에 처리하는 것
- 목적 : 성능 향성, 작업 시간 단축, 자원 효율적 활용

## 동시성 제어
- 여러 작업 (트랜잭션, 프로세스 등) 이 동시에 실행될 때, 발생할 수 있는 데이터의 불일치나 충돌을 예방하고, 데이터의 정확성과 일관성을 유지하기 위한 기술
- Lost Update
  - 동시에 여러 작업이 같은 데이터를 업데이트하면, 일부 작업이 사라져서 데이터 누락 발생
- Inconsistent Read
  - 하나의 작업이 데이터를 읽는 도중, 다른 작업이 데이터를 변경하면, 읽고 있는 데이터에 모순이 발생
- Dirty Read
  - 아직 완료되지 않은 작업의 데이터를 다른 작업이 읽게 되어 잘못된 처리 발생

## 동시성 제어 전략
- Locking
  - 데이터를 사용하거나 변경하기 전에 Lock 을 걸고, 작업이 끝날 때까지 다른 작업이 해당 데이터를 접근하지 못하게 하는 방법
  - Database 에서 주로 사용되는 기술
  - 장점:
    - 구현이 간단, 직관적
    - 충돌을 확실하게 방지
  - 단점:
    - lock 시간이 길어지면 성능이 떨어짐
    - Deadlock 발생 가능성 있음
- Optimistic Control
  - 충돌이 발생하지 않을거라고 가정하고 낙관적으로 작업을 진행
  - 데이터 변경 시 충돌이 발생했는지 검사
  - 충돌이 발견되면, 나중에 처리된 작업을 취소하고 다시 수행
  - 장점:
    - 충돌 빈도가 적을때 성능이 좋음
    - 락 관리에 대한 오버헤드가 적음
  - 단점:
    - 충돌이 빈번하면 오히려 성능이 더 떨어짐
    - 재시도 작업의 오버헤드가 큼
- Timestamp-Based Control
  - 각 작업이 수행된 시간을 기준으로 데이터 접근 순서를 관리
  - 타임스탬프를 비교하여 충돌 여부를 판단하고 충돌이 있을때는 작업을 취소
  - 장점:
    - 락 관리가 필요없어 deadlock이 발생하지 않음
    - 간단한 데이터의 동시성 제어에 유리
  - 단점:
    - 작업이 자주 취소 될 수 있음
    - 많은 작업을 되돌리면 Optimistic Control 과 동일하게 성능이 떨어짐

## 트랜잭션
- 트랜잭션이란, "한 번에 처리되어야 하는 작업 단위"로, 전체가 성공하거나 전체가 실패하는 것을 보장하는 작업
- 은행 돈 이체가 대표적인 예시

## 동시성 제어 ACID 원칙
- A (Atomicity, 원자성)
  - 트랜잭션의 모든 작업은 성공 또는 실패로 끝나야하며, 일부만 실행되지 않는다
- C (Consistency, 일관성)
  - 트랜잭션이 완료된 후에도 데이터의 일관성이 유지
- I (Isolation, 고립성)
  - 트랜잭션은 서로의 중간 상태를 보지 못하며 독립적으로 실행된 것처럼 보여야 한다
- D (Durability, 지속성)
  - 완료된 트랜잭션은 이후 장애가 발생해도 유지됨

## 자바에서 동시성 제어를 하기 위한 방법
- synchronized
  - 자바의 기본 내장 락
  - 단일 락
  - 장점:
    - 문법이 간단
    - 코드가 간결, 자동 해제
  - 단점:
    - 인터럽트 처리 불가능
    - 타임아웃 불가능
    - 락 상태 확인 불가
    - Deadlock 발생 위험 존재
- ReentrantLock
  - java.util.concurrent.locks 패키지 락 클래스
  - synchronized 보다 더 많은 커스텀 가능
  - 단일 락
  - 장점:
    - 인터럽트 가능 -> 유연한 스레드 관리
    - 타임아웃 설정 가능
    - 공정성 옵션 제공 (FIFO 방식으로 thread 락 획득 보장)
  - 단점:
    - lock 이후 unlock 반드시 필요 (finally 문 누락시 Deadlock 발생)
    - 코드가 다소 복잡해짐
- Semaphore
  - 지정된 수 만큼 thread 가 동시 접근 가능 (공용 화장실)
  - 락 소유 개념 없음
  - 지정 thread 개수를 1개로 지정하면 mutex 와 동일한 효과 (자바는 mutex 가 없음)
  - 장점: 
    - N 개의 스레드 동시 접근 허용 가능
    - 락 소유 개념 없음 -> 동적 획득 / 해제 가능
    - DB connection pool 과 같은 리소스 풀 구현에 적합
  - 단점:
    - 같은 thread 가 여러번 acquire 하면 Deadlock 발생
    - 락 소유자가 아니여도 release() 가능 -> 잘못 해제 위험성
    - 설계 복잡도가 높음 -> 제대로된 이해 없이 사용시 버그 유발 가능성 높음


## 구현 방법
- ConcurrentHashMap 과 Semaphore 활용
  - semaphore 접근 개수를 1개로 설정하여, 동시에 자원 접근은 하나의 thread 만 할 수 있도록 제어
  - 단점 : thread 가 많아지면 많아질수록, Delay 가 늘어나게 됨.

  
# 이번 과제에서 부족 했던 점
- Domain 영역에 대한 지식과 그에 대한 탐색이 부족했다.
  - Java 의 MVC 환경에서 Domain 이 가지는 역할이 Python 의 BasicModel 과 같다는 점은 인지하고 있었다.
  - 하지만, 이를 코드에 제대로 녹여내지 못하여서, 과제 Fail 을 받을 뻔 하였다.
- Validation 코드가 과도하였다.
  - Validation 클래스를 따로 만들고, 분리하였는데, 오히려 번잡해지고, 불필요한 낭비였다.
  - 관련 Validation 코드는 Domain 영역에서 검증하도록 처리했어야 했다.
    - 만약 이런식으로 개발 했다면, 더욱 깔끔한 코드가 됐을 것이다.
    - Domain 영역에 대한 정확한 지식 부재에 따른 문제..ㅠ
  - Validation 이 Domain 영역에 있었다면, Domain 에 대한 Unit 테스트가 가능해지면서, 비즈니스 로직에 대한 부담을 나눌 수 있다.

### Q. 궁금했던 점
- 현재의 프로젝트에서 Service 영역의 비즈니스로직을 Domain 영역으로 뺀다고 한다면, Service 영역에서 unit 테스트는 할 수 없는거 아냐?
- 반은 맞다 : 예외가 발생했으면 예외를 핸들링하는지 여부, 원하는대로 순서대로 호출이 되는지 (고유기능)
  - ex) 포인트 충전실패 -> 내역이 저장이 안됨 -> 단위테스트가 없으면, 실제로 실행됐는지 안됐는지 점검이 안됨
  ```
  테스트 "포인트 충전이 실패하면, 포인트 내역과 포인트 변경분은 저장되지 않는다"() {
    // arrange
    충전 실패되는 stub 을 세팅

    // act
    서비스.포인트 충전()

    // assert
    verify(포인트 저장, 0번)
    verify(내역 저장, 0번) // 포인트 저장이 안됐지만, 내역 저장 함수는 정상적으로 호출되어야 한다 (저장은 안하더라도)
    }
  ```

# 에러 추적 기록
## 아고라 공유
테스트코드를 수행시키다가 java.lang.IllegalArgumentException 예외와 함께 500 에러를 만나게 되었습니다.
코드에 문제가 없는데 에러가 계속 발생하더라구요.
app 을 gradlew bootRun 으로 up 시켜서 해도 동일하게 500이 떨어졌었습니다.

결론적으로 -parameters 매개변수를 추가해주어야 하더군요.
intellij > 빌드, 실행, 배포 > 컴파일러 > Java 컴파일러 > 추가 명령줄 매개변수 : -parameters 추가

build.gradle.kts 파일 마지막줄에 다음 추가
tasks.withType<JavaCompile> {
options.compilerArgs.add("-parameters")
}

이러고 나니 모든 코드가 정상동작 했습니다.
컴파일러에서 api 파라미터를 정상적으로 인지하지 못하여 발생하는 오류라고 파악하고 있으나, 정확하진 않습니다.
혹시 아시는분 있으면 공유 부탁드립니다.


[에러 추적 상세 기록]
본 영역은 구구절절 에러를 어떻게 추적하였는지 기록하였습니다. 스킵하셔도 됩니다.

그래서 서비스영역을 아애 배제하고, controller 영역에서 print 를 찍게 하고 테스트를 동작시켰는데, print 문도 안찍혔습니다.
저는, parameter 를 자동으로 validation 하도록 라이브러리를 추가하고, 코드를 수정했는데, 이게 원인인가 싶어서 관련 코드도 싹 삭제하고, 완전히 기본만 있는, parameter 호출, service 영역없이 print 했는데도 print 찍는것 없이 500에러.
그러면 다른 endpoint 를 모두 삭제해보자! 아주 간단한 코드만 남겨두고 테스트. 또 500에러.

저는 GlobalExceptionHandler 를 작성했었습니다.
(코드를 자세히 읽어보셨으면 아셨겠지만, ApiControllerAdvice 에 ExceptionHandler 가 있어요..)
저는 ApiContollerAdvice 에 ExceptionHandler 가 있는줄 몰랐죠..
그래서 제 코드에서 계속 디버깅을 하고, 디버깅이 안잡히고.. 머리쥐어뜯고 반복이였습니다..ㅠㅠ (과제 코드 열심히 분석하고 시작합시다..ㅠ)
그러다 끝에 ApiContollerAdvice 의 ExceptionHandler 를 발견.. 원인을 파악하고, 위의 해결책을 찾아 해결하였습니다.

혹여나.. 제 뻘짓이 누군가에게 도움이 될까 싶어 글을 남깁니다.